/**
 * Doc Generator Service — Generates initial documentation stubs for a project
 *
 * Creates ai-docs/ directory with ARCHITECTURE.md, PATTERNS.md, and FEATURES-INDEX.md
 * based on detected tech stack from codebase analysis. Does not overwrite existing files.
 * All operations are synchronous per service pattern.
 */

import { existsSync, mkdirSync, readdirSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';

import type { CodebaseAnalysis } from '@shared/types/project-setup';

import { serviceLogger } from '@main/lib/logger';

// ─── Constants ──────────────────────────────────────────────

const AI_DOCS_DIR = 'ai-docs';
const MAX_TREE_DEPTH = 2;

const SKIP_DIRS = new Set([
  'node_modules',
  '.git',
  'dist',
  'build',
  '.next',
  'target',
  '__pycache__',
  '.venv',
  '.adc',
]);

// ─── Types ──────────────────────────────────────────────────

export interface DocGeneratorService {
  generateDocs: (
    projectPath: string,
    projectName: string,
    analysis: CodebaseAnalysis,
  ) => void;
}

// ─── Helpers ────────────────────────────────────────────────

/** Generate markdown table rows from the CodebaseAnalysis tech stack */
function generateTechStackRows(analysis: CodebaseAnalysis): string {
  const rows: string[] = [];

  // Languages
  for (const lang of analysis.languages) {
    rows.push(`| Language | ${lang.name} | ${String(lang.percentage)}% |`);
  }

  // Frameworks
  for (const framework of analysis.frameworks) {
    rows.push(`| Framework | ${framework} | - |`);
  }

  // Package manager
  if (analysis.packageManager !== null) {
    rows.push(`| Package Manager | ${analysis.packageManager} | - |`);
  }

  // Build tool
  if (analysis.buildTool !== null) {
    rows.push(`| Build Tool | ${analysis.buildTool} | - |`);
  }

  // Test framework
  if (analysis.testFramework !== null) {
    rows.push(`| Test Framework | ${analysis.testFramework} | - |`);
  }

  // Linter
  if (analysis.linter !== null) {
    rows.push(`| Linter | ${analysis.linter} | - |`);
  }

  // TypeScript
  if (analysis.hasTypeScript) {
    rows.push('| Types | TypeScript | - |');
  }

  // Tailwind
  if (analysis.hasTailwind) {
    rows.push('| Styling | Tailwind CSS | - |');
  }

  // Node version
  if (analysis.nodeVersion !== null) {
    rows.push(`| Runtime | Node.js | ${analysis.nodeVersion} |`);
  }

  // Monorepo tool
  if (analysis.monorepoTool !== null) {
    rows.push(`| Monorepo | ${analysis.monorepoTool} | - |`);
  }

  if (rows.length === 0) {
    rows.push('| (none detected) | - | - |');
  }

  return rows.join('\n');
}

/** Generate a directory tree string up to a given depth, skipping common dirs */
function generateDirectoryTree(
  rootPath: string,
  maxDepth: number,
): string {
  const lines: string[] = [];

  function walk(dirPath: string, prefix: string, depth: number): void {
    if (depth > maxDepth) return;

    try {
      const entries = readdirSync(dirPath, { withFileTypes: true });
      const dirs = entries
        .filter((entry) => entry.isDirectory() && !SKIP_DIRS.has(entry.name))
        .sort((a, b) => a.name.localeCompare(b.name));

      for (const [index, dir] of dirs.entries()) {
        const isLast = index === dirs.length - 1;
        const connector = isLast ? '\u2514\u2500\u2500 ' : '\u251C\u2500\u2500 ';
        const childPrefix = isLast ? '    ' : '\u2502   ';

        lines.push(`${prefix}${connector}${dir.name}/`);
        walk(join(dirPath, dir.name), `${prefix}${childPrefix}`, depth + 1);
      }
    } catch {
      // Cannot read directory — skip
    }
  }

  walk(rootPath, '', 0);

  if (lines.length === 0) {
    return '(empty or inaccessible)';
  }

  return lines.join('\n');
}

/** Build the ARCHITECTURE.md content */
function buildArchitectureDoc(
  projectName: string,
  projectPath: string,
  analysis: CodebaseAnalysis,
): string {
  const techStackRows = generateTechStackRows(analysis);
  const directoryTree = generateDirectoryTree(projectPath, MAX_TREE_DEPTH);

  return `# Architecture Reference

> Auto-generated by ADC Project Setup for **${projectName}**. Fill in details as the project develops.

## System Diagram

TODO: Add system diagram

## Tech Stack

| Layer | Tech | Version |
|-------|------|---------|
${techStackRows}

## Directory Structure

\`\`\`
${directoryTree}
\`\`\`

## Services

TODO: Document services as they are created

## Data Persistence

TODO: Document data storage patterns
`;
}

/** Build the PATTERNS.md content */
function buildPatternsDoc(projectName: string): string {
  return `# Code Patterns & Conventions

> Auto-generated by ADC Project Setup for **${projectName}**. Document patterns as they emerge.

## Component Pattern

TODO: Document component patterns

## Service Pattern

TODO: Document service patterns

## State Management

TODO: Document state management approach

## Error Handling

TODO: Document error handling patterns
`;
}

/** Build the FEATURES-INDEX.md content */
function buildFeaturesIndexDoc(projectName: string): string {
  return `# Features Index

> Auto-generated by ADC Project Setup for **${projectName}**. Add features as they are built.

## Feature Modules

| Feature | Location | Description |
|---------|----------|-------------|
| TODO | TODO | TODO |

## Services

| Service | Location | Description |
|---------|----------|-------------|
| TODO | TODO | TODO |

## Shared Components

| Component | Location | Description |
|-----------|----------|-------------|
| TODO | TODO | TODO |
`;
}

// ─── Factory ────────────────────────────────────────────────

export function createDocGenerator(): DocGeneratorService {
  return {
    generateDocs(
      projectPath: string,
      projectName: string,
      analysis: CodebaseAnalysis,
    ): void {
      const aiDocsDir = join(projectPath, AI_DOCS_DIR);

      // Create ai-docs/ directory if it doesn't exist
      if (!existsSync(aiDocsDir)) {
        mkdirSync(aiDocsDir, { recursive: true });
      }

      // Generate ARCHITECTURE.md (skip if exists)
      const architecturePath = join(aiDocsDir, 'ARCHITECTURE.md');
      if (!existsSync(architecturePath)) {
        const content = buildArchitectureDoc(projectName, projectPath, analysis);
        writeFileSync(architecturePath, content, 'utf-8');
        serviceLogger.info(
          '[DocGenerator] Created ARCHITECTURE.md for',
          projectName,
        );
      }

      // Generate PATTERNS.md (skip if exists)
      const patternsPath = join(aiDocsDir, 'PATTERNS.md');
      if (!existsSync(patternsPath)) {
        const content = buildPatternsDoc(projectName);
        writeFileSync(patternsPath, content, 'utf-8');
        serviceLogger.info('[DocGenerator] Created PATTERNS.md for', projectName);
      }

      // Generate FEATURES-INDEX.md (skip if exists)
      const featuresIndexPath = join(aiDocsDir, 'FEATURES-INDEX.md');
      if (!existsSync(featuresIndexPath)) {
        const content = buildFeaturesIndexDoc(projectName);
        writeFileSync(featuresIndexPath, content, 'utf-8');
        serviceLogger.info(
          '[DocGenerator] Created FEATURES-INDEX.md for',
          projectName,
        );
      }
    },
  };
}

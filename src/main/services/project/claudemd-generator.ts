/**
 * CLAUDE.md Generator Service — Generates a CLAUDE.md content string
 *
 * Produces template-based markdown that gives Claude agents useful context
 * about a project based on codebase analysis results. Does not write to disk;
 * the pipeline orchestrator handles file writing.
 * All operations are synchronous per service pattern.
 */

import { existsSync, readFileSync, readdirSync } from 'node:fs';
import { join } from 'node:path';

import type { CodebaseAnalysis } from '@shared/types/project-setup';

import { serviceLogger } from '@main/lib/logger';

// ─── Constants ──────────────────────────────────────────────

const MAX_TREE_DEPTH = 2;

const SKIP_DIRS = new Set([
  'node_modules',
  '.git',
  'dist',
  'build',
  '.next',
  'target',
  '__pycache__',
  '.venv',
  '.adc',
]);

const APPEND_MARKER = `

---

<!-- AUTO-GENERATED BY ADC PROJECT SETUP -->
<!-- Review and merge the sections below into your existing CLAUDE.md -->

`;

// ─── Types ──────────────────────────────────────────────────

export interface ClaudeMdGeneratorService {
  generateClaudeMd: (
    projectName: string,
    projectPath: string,
    analysis: CodebaseAnalysis,
  ) => string;
}

// ─── Helpers ────────────────────────────────────────────────

/** Read and parse a JSON file, returning null on failure */
function readJsonSafe(filePath: string): Record<string, unknown> | null {
  try {
    if (!existsSync(filePath)) return null;
    const raw = readFileSync(filePath, 'utf-8');
    return JSON.parse(raw) as Record<string, unknown>;
  } catch {
    return null;
  }
}

/** Extract script commands from package.json */
function extractScripts(
  packageJson: Record<string, unknown>,
): Record<string, string> {
  const { scripts } = packageJson;
  if (typeof scripts !== 'object' || scripts === null) return {};
  return scripts as Record<string, string>;
}

/** Build the Quick Reference section from package.json scripts */
function buildQuickReference(
  projectPath: string,
  packageManager: string | null,
): string {
  const packageJson = readJsonSafe(join(projectPath, 'package.json'));
  const pm = packageManager ?? 'npm';
  const runCmd = pm === 'npm' ? 'npm run' : `${pm} run`;

  if (!packageJson) {
    return `## Quick Reference

\`\`\`bash
${runCmd} dev          # Start development server
${runCmd} build        # Production build
${runCmd} test         # Run tests
\`\`\`
`;
  }

  const scripts = extractScripts(packageJson);
  const targetScripts = [
    'dev',
    'start',
    'build',
    'lint',
    'lint:fix',
    'test',
    'format',
    'typecheck',
  ];
  const lines: string[] = [];

  for (const name of targetScripts) {
    if (name in scripts) {
      lines.push(`${runCmd} ${name}`);
    }
  }

  if (lines.length === 0) {
    // Show all available scripts if none of the standard ones exist
    for (const name of Object.keys(scripts)) {
      lines.push(`${runCmd} ${name}`);
    }
  }

  if (lines.length === 0) {
    return '';
  }

  return `## Quick Reference

\`\`\`bash
${lines.join('\n')}
\`\`\`
`;
}

/** Build the Tech Stack table from CodebaseAnalysis */
function buildTechStackTable(analysis: CodebaseAnalysis): string {
  const rows: string[] = [];

  for (const lang of analysis.languages) {
    rows.push(`| Language | ${lang.name} | ${String(lang.percentage)}% |`);
  }

  for (const framework of analysis.frameworks) {
    rows.push(`| Framework | ${framework} | - |`);
  }

  if (analysis.packageManager !== null) {
    rows.push(`| Package Manager | ${analysis.packageManager} | - |`);
  }

  if (analysis.buildTool !== null) {
    rows.push(`| Build Tool | ${analysis.buildTool} | - |`);
  }

  if (analysis.testFramework !== null) {
    rows.push(`| Test Framework | ${analysis.testFramework} | - |`);
  }

  if (analysis.linter !== null) {
    rows.push(`| Linter | ${analysis.linter} | - |`);
  }

  if (analysis.hasTypeScript) {
    rows.push('| Types | TypeScript | - |');
  }

  if (analysis.hasTailwind) {
    rows.push('| Styling | Tailwind CSS | - |');
  }

  if (analysis.nodeVersion !== null) {
    rows.push(`| Runtime | Node.js | ${analysis.nodeVersion} |`);
  }

  if (analysis.monorepoTool !== null) {
    rows.push(`| Monorepo | ${analysis.monorepoTool} | - |`);
  }

  if (rows.length === 0) {
    return '';
  }

  return `## Tech Stack

| Layer | Tech | Version |
|-------|------|---------|
${rows.join('\n')}
`;
}

/** Generate a directory tree string up to a given depth, skipping common dirs */
function buildDirectoryTree(rootPath: string): string {
  const lines: string[] = [];

  function walk(dirPath: string, prefix: string, depth: number): void {
    if (depth > MAX_TREE_DEPTH) return;

    try {
      const entries = readdirSync(dirPath, { withFileTypes: true });
      const dirs = entries
        .filter((entry) => entry.isDirectory() && !SKIP_DIRS.has(entry.name))
        .sort((a, b) => a.name.localeCompare(b.name));

      for (const [index, dir] of dirs.entries()) {
        const isLast = index === dirs.length - 1;
        const connector = isLast ? '\u2514\u2500\u2500 ' : '\u251C\u2500\u2500 ';
        const childPrefix = isLast ? '    ' : '\u2502   ';

        lines.push(`${prefix}${connector}${dir.name}/`);
        walk(join(dirPath, dir.name), `${prefix}${childPrefix}`, depth + 1);
      }
    } catch {
      // Cannot read directory — skip
    }
  }

  walk(rootPath, '', 0);

  if (lines.length === 0) {
    return '';
  }

  return `## Architecture Skeleton

\`\`\`
${lines.join('\n')}
\`\`\`
`;
}

/** Build framework-specific key patterns section */
function buildKeyPatterns(analysis: CodebaseAnalysis): string {
  const sections: string[] = [];

  // React patterns
  if (analysis.frameworks.includes('react')) {
    sections.push(`### React

- Use named function declarations for components (not arrow functions)
- Hooks first, then derived state, then handlers, then render
- Self-closing tags for empty elements: \`<Component />\`
- Ternary for conditional rendering (not \`&&\`)
`);
  }

  // TypeScript patterns
  if (analysis.hasTypeScript) {
    sections.push(`### TypeScript

- Use \`import type { T }\` for type-only imports
- Avoid \`any\` — use \`unknown\` with type narrowing
- No non-null assertions (\`!\`) — use \`?? fallback\` or proper null checks
- Use \`node:\` protocol for Node.js builtins (\`import { join } from 'node:path'\`)
`);
  }

  // ESLint patterns
  if (analysis.linter === 'eslint') {
    sections.push(`### ESLint

- Zero-tolerance policy — all violations must be fixed
- Run \`npm run lint\` before committing
`);
  }

  // Tailwind patterns
  if (analysis.hasTailwind) {
    sections.push(`### Tailwind CSS

- Use CSS custom properties with Tailwind utility classes for theming
- Avoid hardcoded color values in utility classes — use theme tokens
`);
  }

  if (sections.length === 0) {
    return '';
  }

  return `## Key Patterns

${sections.join('\n')}`;
}

/** Build import order convention section (TypeScript only) */
function buildImportOrder(analysis: CodebaseAnalysis): string {
  if (!analysis.hasTypeScript) return '';

  return `## Import Order

\`\`\`typescript
// 1. Node builtins
import { join } from 'node:path';

// 2. External packages
import { useState } from 'react';

// 3. Internal aliases
import type { MyType } from '@shared/types';

// 4. Relative imports
import { MyComponent } from './MyComponent';
\`\`\`

Blank line between each group. Alphabetical within groups.
`;
}

// ─── Factory ────────────────────────────────────────────────

export function createClaudeMdGenerator(): ClaudeMdGeneratorService {
  return {
    generateClaudeMd(
      projectName: string,
      projectPath: string,
      analysis: CodebaseAnalysis,
    ): string {
      // Build each section conditionally
      const sections: string[] = [];

      // Header
      sections.push(`# ${projectName} — Guidelines

> Auto-generated by ADC Project Setup. Review and customize for your project.
`);

      // Quick Reference
      const quickRef = buildQuickReference(projectPath, analysis.packageManager);
      if (quickRef.length > 0) {
        sections.push(quickRef);
      }

      // Tech Stack Table
      const techStack = buildTechStackTable(analysis);
      if (techStack.length > 0) {
        sections.push(techStack);
      }

      // Architecture Skeleton
      const dirTree = buildDirectoryTree(projectPath);
      if (dirTree.length > 0) {
        sections.push(dirTree);
      }

      // Key Patterns
      const patterns = buildKeyPatterns(analysis);
      if (patterns.length > 0) {
        sections.push(patterns);
      }

      // Import Order
      const importOrder = buildImportOrder(analysis);
      if (importOrder.length > 0) {
        sections.push(importOrder);
      }

      const generatedContent = sections.join('\n');

      // Merge behavior: append to existing CLAUDE.md if it exists
      const existingClaudeMdPath = join(projectPath, 'CLAUDE.md');
      if (existsSync(existingClaudeMdPath)) {
        try {
          const existingContent = readFileSync(existingClaudeMdPath, 'utf-8');
          return existingContent + APPEND_MARKER + generatedContent;
        } catch {
          // Cannot read existing file — return generated content only
          serviceLogger.error(
            '[ClaudeMdGenerator] Failed to read existing CLAUDE.md, returning generated content only',
          );
          return generatedContent;
        }
      }

      return generatedContent;
    },
  };
}
